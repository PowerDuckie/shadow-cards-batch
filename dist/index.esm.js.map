{"version":3,"file":"index.esm.js","sources":["../src/constants.js","../node_modules/uuid/dist/stringify.js","../node_modules/uuid/dist/rng.js","../node_modules/uuid/dist/native.js","../node_modules/uuid/dist/v4.js","../src/utils.js","../src/index.js"],"sourcesContent":["/**\n * Default configuration options for ShadowCard instances\n */\nexport const DEFAULT_OPTIONS = {\n    targetWidth: 160,\n    container: document.body,\n    html: '',\n    css: '',\n    data: {}\n};\n\n/**\n * Event type constants for consistent event handling\n */\nexport const EVENT_TYPES = {\n    CONTENT_CHANGE: 'content-change',\n    IMG_CLICK: 'img-click',\n    ERROR: 'error'\n};\n\n/**\n * Error message constants for consistent error reporting\n */\nexport const ERROR_MESSAGES = {\n    INVALID_CONTAINER: 'Container must be a valid DOM element',\n    INVALID_HTML: 'HTML content must be a string',\n    INVALID_CSS: 'Styles must be a string',\n    INVALID_DATA: 'Data must be an object',\n    INVALID_TARGET_WIDTH: 'Target width must be a positive number',\n    ELEMENT_DESTROYED: 'Card has been destroyed and cannot perform operations'\n};","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","import { ERROR_MESSAGES } from './constants.js';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Generates a unique ID for card identification\n * @returns {string} Unique alphanumeric ID\n */\nexport function generateUniqueId() {\n    return `shadow-card-${uuidv4()}`;\n}\n\n/**\n * Calculates scaling ratio and dimensions for proper card sizing\n * @param {HTMLElement} container - Content container element\n * @param {number} targetWidth - Desired display width\n * @returns {Object} Scaling details { scale, width, height }\n */\nexport function calculateScaling(container, targetWidth) {\n    if (!container || !(container instanceof HTMLElement)) {\n        throw new Error(ERRORMessages.INVALID_CONTAINER);\n    }\n    if (typeof targetWidth !== 'number' || targetWidth <= 0) {\n        throw new Error(ERRORMessagesERROR_MESSAGES.INVALID_TARGET_WIDTH);\n    }\n\n    // Prevent division by zero with minimum dimension of 1px\n    const originalWidth = Math.max(1, container.offsetWidth);\n    const originalHeight = Math.max(1, container.offsetHeight);\n    const scale = targetWidth / originalWidth;\n\n    return {\n        scale: Number(scale.toFixed(6)), // Limit precision to 6 decimal places\n        width: Math.round(originalWidth * scale),\n        height: Math.round(originalHeight * scale)\n    };\n}\n\n/**\n * Input validation utility for ensuring type safety and valid values\n */\nexport const Validator = {\n    /**\n     * Validates that a container is a valid HTML element\n     * @param {*} container - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateContainer(container) {\n        if (!(container instanceof HTMLElement)) {\n            throw new Error(ERROR_MESSAGES.INVALID_CONTAINER);\n        }\n    },\n\n    /**\n     * Validates that HTML content is a string\n     * @param {*} html - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateHtml(html) {\n        if (typeof html !== 'string') {\n            throw new Error(ERROR_MESSAGES.INVALID_HTML);\n        }\n    },\n\n    /**\n     * Validates that CSS content is a string\n     * @param {*} css - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateCss(css) {\n        if (typeof css !== 'string') {\n            throw new Error(ERROR_MESSAGES.INVALID_CSS);\n        }\n    },\n\n    /**\n     * Validates that data is a valid object\n     * @param {*} data - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateData(data) {\n        if (data !== null && typeof data !== 'object') {\n            throw new Error(ERROR_MESSAGES.INVALID_DATA);\n        }\n    },\n\n    /**\n     * Validates that target width is a positive number\n     * @param {*} width - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateTargetWidth(width) {\n        if (typeof width !== 'number' || width <= 0 || isNaN(width)) {\n            throw new Error(ERROR_MESSAGES.INVALID_TARGET_WIDTH);\n        }\n    },\n\n    /**\n     * Validates that a card instance hasn't been destroyed\n     * @param {Object} instance - Card instance to check\n     * @throws {Error} Throws error if instance is destroyed\n     */\n    validateNotDestroyed(instance) {\n        if (instance.isDestroyed) {\n            throw new Error(ERROR_MESSAGES.ELEMENT_DESTROYED);\n        }\n    }\n};","import { generateUniqueId, calculateScaling, Validator } from './utils.js';\nimport { DEFAULT_OPTIONS, EVENT_TYPES } from './constants.js';\n\n/**\n * ShadowCard class - Creates isolated card instances using Shadow DOM\n * Supports batch creation, dynamic updates to HTML, styles, and content\n */\nexport class ShadowCard {\n    /**\n     * Initialize a new ShadowCard instance\n     * @param {Object} options - Configuration options\n     * @param {HTMLElement} options.container - Parent element to mount the card (defaults to document.body)\n     * @param {string} options.html - HTML structure for the card content\n     * @param {string} options.css - CSS styles scoped to the card\n     * @param {Object} options.data - Initial content data ({ field: value } key-value pairs)\n     * @param {number} options.targetWidth - Desired display width (defaults to 160)\n     */\n    constructor(options = {}) {\n        try {\n            // Merge user options with defaults\n            this.options = { ...DEFAULT_OPTIONS, ...options };\n\n            // Validate input parameters\n            Validator.validateContainer(this.options.container);\n            Validator.validateHtml(this.options.html);\n            Validator.validateCss(this.options.css);\n            Validator.validateData(this.options.data);\n            Validator.validateTargetWidth(this.options.targetWidth);\n\n            // Initialize instance state\n            this.id = generateUniqueId();\n            this.isDestroyed = false;\n            this.data = { ...this.options.data };\n            this.eventListeners = new Map(); // Track listeners for proper cleanup\n            this.resizeTimer = null; // Timer ID for resize debouncing\n\n            // Create core DOM structure\n            this.element = this.createHostElement();\n            this.shadow = this.element.shadowRoot;\n            this.innerContainer = this.shadow.getElementById('inner-container');\n\n            // Initialize content and styles\n            this.setHTML(this.options.html);\n            this.setStyle(this.options.css);\n            this.setContent(this.options.data);\n\n            // Mount to container\n            this.options.container.appendChild(this.element);\n\n            // Defer resize to ensure DOM rendering completes\n            this.resizeTimer = setTimeout(async () => {\n                await this.resize();\n            }, 0);\n\n\n        } catch (error) {\n            this.dispatchError(error.message);\n            throw error; // Propagate error for developer visibility\n        }\n    }\n\n    /**\n     * Wait for all images in the card to load\n     * @returns {Promise} Resolves when all images are loaded/failed\n     */\n    waitForImages() {\n        return new Promise((resolve) => {\n            const images = Array.from(this.shadow.querySelectorAll('img'));\n            if (images.length === 0) {\n                resolve();\n                return;\n            }\n\n            let loadedCount = 0;\n            const checkComplete = () => {\n                loadedCount++;\n                if (loadedCount === images.length) {\n                    resolve();\n                }\n            };\n\n            images.forEach(img => {\n                // If already loaded/failed\n                if (img.complete) {\n                    checkComplete();\n                    return;\n                }\n                // Listen for load events\n                img.addEventListener('load', checkComplete, { once: true });\n                // Listen for error events (still count as \"processed\")\n                img.addEventListener('error', checkComplete, { once: true });\n            });\n        });\n    }\n\n    /**\n     * Create the host element with Shadow DOM\n     * @returns {HTMLElement} Custom element with shadow root\n     */\n    createHostElement() {\n        const element = document.createElement('shadow-card');\n        element.id = this.id;\n        element.dataset.id = this.id;\n\n        // Apply style options as CSS variables (from constructor options)\n        this.applyStyleVariables(element);\n\n        const shadow = element.attachShadow({ mode: 'open' });\n        shadow.innerHTML = `\n        <style>\n        :host {\n            all: initial;\n            display: block;\n            border: var(--shadow-card-border, 2px solid var(--shadow-card-border-color));\n            border-radius: var(--shadow-card-border-radius, 6px);\n            cursor: pointer;\n            overflow: hidden;\n            box-sizing: border-box;\n            transition: border 0.3s ease;\n            user-select: none;\n            position: relative;\n            margin: ${this.options?.styles?.marginHeight || \"8px\"} ${this.options?.styles?.marginWitdh || \"auto\"};\n        }\n        \n        :host(:hover) {\n            border-color: var(--shadow-card-hover-border-color, #3b82f6);\n        }\n        \n        #inner-container {\n            // width: 100%;\n            width:640px;\n            transform-origin: top left;\n            transform: scale(1);\n        }\n        \n        #loading-overlay {\n            position: absolute;\n            inset: 0;\n            background: var(--shadow-card-loading-bg, #ffffff);\n            color: var(--shadow-card-loading-color, #4b5563);\n            font-size: var(--shadow-card-loading-font-size, 0.8rem);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            gap: var(--shadow-card-loading-gap, 8px);\n            z-index: 10;\n            opacity: 1;\n            transition: opacity 0.3s ease;\n        }\n        \n        .loading-spinner {\n            width: var(--shadow-card-loading-icon-size, 20px);\n            height: var(--shadow-card-loading-icon-size, 20px);\n            border: 2px solid var(--shadow-card-loading-spinner-border, rgba(0, 0, 0, 0.1));\n            border-top-color: var(--shadow-card-loading-spinner-color, #3b82f6);\n            border-radius: 50%;\n            animation: spin var(--shadow-card-loading-spinner-speed, 1s) linear infinite;\n        }\n        \n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n        \n        #loading-overlay.hidden {\n            opacity: 0;\n            pointer-events: none;\n        }\n        </style>\n        <div id=\"loading-overlay\">\n            <div class=\"loading-spinner\"></div>\n            <span class=\"loading-text\">${this.options?.styles?.loadingText || 'Loading...'}</span>\n        </div>\n        <div id=\"inner-container\"></div>\n    `;\n\n        this.boundInputHandler = (e) => this.handleInput(e);\n        this.boundClickHandler = (e) => this.handleClick(e);\n        shadow.addEventListener('input', this.boundInputHandler);\n        shadow.addEventListener('click', this.boundClickHandler);\n        this.boundPasteHandler = (e) => this.handlePaste(e);\n        shadow.addEventListener('paste', this.boundPasteHandler);\n        return element;\n    }\n\n    // Handles paste events for contenteditable elements to enforce plain text only\n    handlePaste(e) {\n        // Exit early if target isn't an editable element or event is already handled\n        if (!e.target?.isContentEditable || e.defaultPrevented) return;\n\n        // Prevent default paste behavior to block rich content\n        e.preventDefault();\n\n        try {\n            // Get clipboard data source (standard Clipboard API or legacy IE support)\n            const clipboardData = e.clipboardData || window.clipboardData;\n            if (!clipboardData) throw new Error('Clipboard access unavailable');\n\n            // Extract only plain text from clipboard (ignores HTML, images, etc.)\n            const plainText = clipboardData.getData('text') || '';\n            if (plainText.trim() === '') return; // Do nothing if clipboard is empty\n\n            // Get current selection/cursor position\n            const selection = window.getSelection();\n            if (!selection || selection.rangeCount === 0) {\n                // Fallback: append to end if no valid selection\n                e.target.textContent += plainText;\n                return;\n            }\n\n            // Remove any currently selected content before pasting\n            const range = selection.getRangeAt(0);\n            range.deleteContents();\n\n            // Create text node with clipboard content\n            const textNode = document.createTextNode(plainText);\n\n            // Insert text at cursor position\n            range.insertNode(textNode);\n\n            // Move cursor to end of pasted text for natural continuation\n            range.setStartAfter(textNode);\n            range.setEndAfter(textNode);\n\n            // Update selection to new cursor position\n            selection.removeAllRanges();\n            selection.addRange(range);\n\n        } catch (error) {\n            // Graceful fallback: append text to end if main logic fails\n            console.warn('Plain text paste enforcement failed:', error);\n            e.target.textContent += (e.clipboardData || window.clipboardData)?.getData('text') || '';\n        }\n    }\n\n    /**\n     * Applies initial style options as CSS variables to the host element\n     * @param {HTMLElement} element - Host element to apply styles to\n     * @private\n     */\n    applyStyleVariables(element) {\n        // Guard clause: Validate element exists before proceeding\n        if (!element || !(element instanceof HTMLElement)) {\n            console.error('Invalid element passed to applyStyleVariables. Must be an HTMLElement.');\n            return;\n        }\n\n        try {\n            // Get style mappings from centralized method\n            const styleMappings = this.getStyleMappings();\n\n            // Only proceed if styles option exists and is an object\n            if (this.options?.styles && typeof this.options.styles === 'object') {\n                // Apply each valid style option as a CSS variable\n                Object.entries(styleMappings).forEach(([optionKey, cssVar]) => {\n                    // Check if the specific style property exists in options\n                    if (this.options.styles[optionKey] !== undefined) {\n                        // Use try/catch around setProperty for additional safety\n                        try {\n                            element.style.setProperty(cssVar, this.options.styles[optionKey]);\n                        } catch (setPropertyError) {\n                            console.error(`Failed to set CSS variable ${cssVar}:`, setPropertyError);\n                        }\n                    }\n                });\n            }\n        } catch (error) {\n            console.error('Error in applyStyleVariables:', error);\n        }\n    }\n\n    /**\n     * Returns consistent style mapping between option keys and CSS variables\n     * @returns {Object} Key-value pairs of style options to CSS variables\n     * @private\n     */\n    getStyleMappings() {\n        return {\n            border: '--shadow-card-border',\n            borderColor: '--shadow-card-border-color',\n            borderRadius: '--shadow-card-border-radius',\n            hoverBorderColor: '--shadow-card-hover-border-color',\n            loadingBg: '--shadow-card-loading-bg',\n            loadingColor: '--shadow-card-loading-color',\n            loadingFontSize: '--shadow-card-loading-font-size',\n            loadingGap: '--shadow-card-loading-gap',\n            loadingIconSize: '--shadow-card-loading-icon-size',\n            loadingSpinnerBorder: '--shadow-card-loading-spinner-border',\n            loadingSpinnerColor: '--shadow-card-loading-spinner-color',\n            loadingSpinnerSpeed: '--shadow-card-loading-spinner-speed',\n            loadingText: '--shadow-card-loading-text'\n        };\n    }\n\n    /**\n     * Public API to dynamically update CSS variables for the card\n     * @param {Object} variables - Key-value pairs of style options to update\n     * @returns {ShadowCard} Instance for method chaining\n     * @public\n     */\n    setCssVariables(variables) {\n        try {\n            // Validate the card isn't destroyed\n            Validator.validateNotDestroyed(this);\n\n            // Validate input is a valid object\n            if (typeof variables !== 'object' || variables === null) {\n                throw new Error('Style variables must be a valid object');\n            }\n\n            // Reuse the same style mappings for consistency\n            const styleMappings = this.getStyleMappings();\n\n            // Apply each variable to the host element's style\n            Object.entries(variables).forEach(([optionKey, value]) => {\n                const cssVar = styleMappings[optionKey];\n                if (cssVar && value !== undefined) {\n                    this.element.style.setProperty(cssVar, value);\n                }\n            });\n\n            // Special handling for loading text (updates DOM text content)\n            if (variables.loadingText) {\n                const loadingTextEl = this.shadow.querySelector('.loading-text');\n                if (loadingTextEl) {\n                    loadingTextEl.textContent = variables.loadingText;\n                }\n            }\n\n            return this; // Enable method chaining\n        } catch (error) {\n            this.dispatchError(error.message);\n            return this;\n        }\n    }\n\n    /**\n     * Handle content editing events\n     * @param {Event} e - Input event object\n     */\n    handleInput(e) {\n        if (this.isDestroyed) return;\n\n        const target = e.target;\n        if (target.isContentEditable && target.hasAttribute('data-field')) {\n            try {\n                const field = target.getAttribute('data-field');\n                const value = target.innerText;\n                this.data[field] = value;\n                this.dispatchEvent(EVENT_TYPES.CONTENT_CHANGE, { field, value });\n            } catch (error) {\n                this.dispatchError(error.message);\n            }\n        }\n    }\n\n    /**\n     * Handle image click events\n     * @param {Event} e - Click event object\n     */\n    handleClick(e) {\n        if (this.isDestroyed) return;\n\n        const target = e.target;\n        if (target.tagName === 'IMG' && target.hasAttribute('data-img')) {\n            try {\n                this.dispatchEvent(EVENT_TYPES.IMG_CLICK, {\n                    imgKey: target.getAttribute('data-img'),\n                    element: target\n                });\n            } catch (error) {\n                this.dispatchError(error.message);\n            }\n        }\n    }\n\n    /**\n     * Dispatch custom events\n     * @param {string} type - Event type\n     * @param {Object} detail - Event payload\n     */\n    dispatchEvent(type, detail) {\n        if (this.isDestroyed) return;\n\n        this.element.dispatchEvent(new CustomEvent(type, {\n            detail: { ...detail, cardId: this.id },\n            bubbles: true,\n            cancelable: true\n        }));\n    }\n\n    /**\n     * Dispatch error events\n     * @param {string} message - Error description\n     */\n    dispatchError(message) {\n        this.dispatchEvent(EVENT_TYPES.ERROR, { message });\n    }\n\n    /**\n     * Update card's HTML content\n     * @param {string} html - New HTML content\n     * @returns {ShadowCard} Instance for chaining\n     */\n    async setHTML(html) {\n        try {\n            Validator.validateNotDestroyed(this);\n            Validator.validateHtml(html);\n\n            this.innerContainer.innerHTML = html;\n            this.innerContainer.offsetHeight; // Force reflow\n            await this.resize(); // Wait for async resize to complete\n            return this;\n        } catch (error) {\n            this.dispatchError(error.message);\n            return this;\n        }\n    }\n\n    /**\n     * Update card's styles\n     * @param {string} css - CSS rules\n     * @param {boolean} [reset=false] - Replace existing styles if true\n     * @returns {ShadowCard} Instance for chaining\n     */\n    setStyle(css, reset = false) {\n        try {\n            Validator.validateNotDestroyed(this);\n            Validator.validateCss(css);\n\n            let styleEl = this.shadow.querySelector('#custom-style');\n            if (!styleEl) {\n                styleEl = document.createElement('style');\n                styleEl.id = 'custom-style';\n                this.shadow.insertBefore(styleEl, this.innerContainer);\n            }\n\n            styleEl.textContent = reset ? css : `${styleEl.textContent}\\n${css}`;\n            return this;\n        } catch (error) {\n            this.dispatchError(error.message);\n            return this;\n        }\n    }\n\n    /**\n     * Update editable content fields\n     * @param {Object} data - { field: value } updates\n     * @returns {ShadowCard} Instance for chaining\n     */\n    setContent(data) {\n        try {\n            Validator.validateNotDestroyed(this);\n            Validator.validateData(data);\n\n            this.data = { ...this.data, ...data };\n            Object.entries(data).forEach(([field, value]) => {\n                const element = this.shadow.querySelector(`[data-field=\"${field}\"]`);\n                if (element?.isContentEditable) {\n                    element.innerText = value == null ? '' : String(value);\n                }\n            });\n            return this;\n        } catch (error) {\n            this.dispatchError(error.message);\n            return this;\n        }\n    }\n\n    /**\n     * Resize card to target width\n     * @param {number} [targetWidth] - New target width (uses initial if not provided)\n     * @returns {ShadowCard} Instance for chaining\n     */\n    async resize(targetWidth) {\n        try {\n            Validator.validateNotDestroyed(this);\n            const loadingOverlay = this.shadow.querySelector('#loading-overlay');\n            loadingOverlay.classList.remove('hidden');\n\n            // Update target width if provided\n            if (targetWidth !== undefined) {\n                Validator.validateTargetWidth(targetWidth);\n                this.options.targetWidth = targetWidth;\n            }\n\n            // 1. Force setting of the width of the card container (the outer container)\n            this.element.style.width = `${this.options.targetWidth}px`;\n            this.element.style.height = 'auto';\n\n            // 2. Wait for the image to load completely to obtain the accurate dimensions\n            await this.waitForImages();\n\n            // 3. Calculate the scaling ratio (based on the original width of the internal content)\n            const originalContentWidth = this.innerContainer.offsetWidth;\n            if (originalContentWidth === 0) {\n                this.innerContainer.style.minWidth = '1px';\n                this.innerContainer.style.minHeight = '1px';\n                // Recalculate the width to avoid division by zero\n                originalContentWidth = Math.max(1, this.innerContainer.offsetWidth);\n            }\n\n            // Core: Calculate the scaling ratio (target width / original content width)\n            const scale = this.options.targetWidth / originalContentWidth;\n\n            // 4. Apply scaling and adjust height\n            this.innerContainer.style.transform = `scale(${scale})`;\n            this.innerContainer.style.transformOrigin = 'top left'; // Ensure that the scaling starts from the top left corner\n\n            // Calculate the actual height after scaling (original height * scaling ratio)\n            const scaledHeight = Math.max(1, this.innerContainer.offsetHeight * scale);\n            this.element.style.height = `${scaledHeight}px`;\n\n            // 5. Ensure that the internal content does not overflow\n            this.innerContainer.style.width = `${this.options.targetWidth / scale}px`; // Reverse the internal width of the scaling\n            this.innerContainer.style.overflow = 'hidden';\n\n            // 6. After the layout is completed, hide the loading status\n            requestAnimationFrame(() => {\n                loadingOverlay.classList.add('hidden');\n            });\n\n            return this;\n        } catch (error) {\n            this.dispatchError(error.message);\n            this.shadow?.querySelector('#loading-overlay')?.classList.add('hidden');\n            return this;\n        }\n    }\n\n    /**\n     * Add event listener\n     * @param {string} type - Event type\n     * @param {Function} handler - Event handler\n     * @returns {ShadowCard} Instance for chaining\n     */\n    on(type, handler) {\n        if (this.isDestroyed) return this;\n\n        if (typeof handler !== 'function') {\n            this.dispatchError('Event handler must be a function');\n            return this;\n        }\n\n        if (!this.eventListeners.has(type)) {\n            this.eventListeners.set(type, new Set());\n        }\n        this.eventListeners.get(type).add(handler);\n        this.element.addEventListener(type, handler);\n        return this;\n    }\n\n    /**\n     * Remove event listener\n     * @param {string} type - Event type\n     * @param {Function} [handler] - Specific handler to remove (removes all if omitted)\n     * @returns {ShadowCard} Instance for chaining\n     */\n    off(type, handler) {\n        if (this.isDestroyed) return this;\n\n        const handlers = this.eventListeners.get(type);\n        if (!handlers) return this;\n\n        if (handler) {\n            handlers.delete(handler);\n            this.element.removeEventListener(type, handler);\n        } else {\n            handlers.forEach(h => this.element.removeEventListener(type, h));\n            handlers.clear();\n        }\n        return this;\n    }\n\n    /**\n     * Destroy card and clean up resources\n     */\n    destroy() {\n        if (this.isDestroyed) return;\n\n        // Clean up timers and event listeners\n        clearTimeout(this.resizeTimer);\n        this.eventListeners.forEach((handlers, type) => {\n            handlers.forEach(handler => this.element.removeEventListener(type, handler));\n        });\n        this.eventListeners.clear();\n\n        // Remove shadow DOM event listeners\n        this.shadow?.removeEventListener('input', this.boundInputHandler);\n        this.shadow?.removeEventListener('click', this.boundClickHandler);\n        this.shadow?.removeEventListener('paste', this.boundPasteHandler);\n\n        // Remove from DOM\n        this.element?.parentNode?.removeChild(this.element);\n\n        // Mark as destroyed and nullify references\n        this.isDestroyed = true;\n        this.element = null;\n        this.shadow = null;\n        this.innerContainer = null;\n        this.data = null;\n        this.options = null;\n    }\n\n    /**\n     * Batch create multiple ShadowCard instances\n     * @param {Object[]} cards - Array of card configurations\n     * @returns {ShadowCard[]} Array of created instances\n     */\n    static batchCreate(cards) {\n        if (!Array.isArray(cards)) {\n            throw new Error('batchCreate requires an array of card configurations');\n        }\n\n        return cards.map(options => new ShadowCard(options));\n    }\n}\n\nexport default ShadowCard;"],"names":["DEFAULT_OPTIONS","targetWidth","container","document","body","html","css","data","EVENT_TYPES","ERROR_MESSAGES","byteToHex","i","push","toString","slice","getRandomValues","rnds8","Uint8Array","native","randomUUID","crypto","bind","_v4","options","buf","offset","rnds","random","rng","Error","length","arr","toLowerCase","unsafeStringify","generateUniqueId","Validator","validateContainer","HTMLElement","validateHtml","validateCss","validateData","validateTargetWidth","width","isNaN","validateNotDestroyed","instance","isDestroyed","ShadowCard","constructor","this","id","eventListeners","Map","resizeTimer","element","createHostElement","shadow","shadowRoot","innerContainer","getElementById","setHTML","setStyle","setContent","appendChild","setTimeout","async","resize","error","dispatchError","message","waitForImages","Promise","resolve","images","Array","from","querySelectorAll","loadedCount","checkComplete","forEach","img","complete","addEventListener","once","createElement","dataset","applyStyleVariables","attachShadow","mode","innerHTML","styles","marginHeight","marginWitdh","loadingText","boundInputHandler","e","handleInput","boundClickHandler","handleClick","boundPasteHandler","handlePaste","target","isContentEditable","defaultPrevented","preventDefault","clipboardData","window","plainText","getData","trim","selection","getSelection","rangeCount","textContent","range","getRangeAt","deleteContents","textNode","createTextNode","insertNode","setStartAfter","setEndAfter","removeAllRanges","addRange","console","warn","styleMappings","getStyleMappings","Object","entries","optionKey","cssVar","undefined","style","setProperty","setPropertyError","border","borderColor","borderRadius","hoverBorderColor","loadingBg","loadingColor","loadingFontSize","loadingGap","loadingIconSize","loadingSpinnerBorder","loadingSpinnerColor","loadingSpinnerSpeed","setCssVariables","variables","value","loadingTextEl","querySelector","hasAttribute","field","getAttribute","innerText","dispatchEvent","tagName","imgKey","type","detail","CustomEvent","cardId","bubbles","cancelable","offsetHeight","reset","styleEl","insertBefore","String","loadingOverlay","classList","remove","height","originalContentWidth","offsetWidth","minWidth","minHeight","Math","max","scale","transform","transformOrigin","scaledHeight","overflow","requestAnimationFrame","add","on","handler","has","set","Set","get","off","handlers","delete","removeEventListener","h","clear","destroy","clearTimeout","parentNode","removeChild","batchCreate","cards","isArray","map"],"mappings":"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","x_google_ignoreList":[1,2,3,4]}