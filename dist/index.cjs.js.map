{"version":3,"file":"index.cjs.js","sources":["../src/constants.js","../node_modules/uuid/dist/stringify.js","../node_modules/uuid/dist/rng.js","../node_modules/uuid/dist/native.js","../node_modules/uuid/dist/v4.js","../src/utils.js","../src/index.js"],"sourcesContent":["/**\n * Default configuration options for ShadowCard instances\n */\nexport const DEFAULT_OPTIONS = {\n    targetWidth: 160,\n    container: document.body,\n    html: '',\n    css: '',\n    data: {}\n};\n\n/**\n * Event type constants for consistent event handling\n */\nexport const EVENT_TYPES = {\n    CONTENT_CHANGE: 'content-change',\n    IMG_CLICK: 'img-click',\n    ERROR: 'error'\n};\n\n/**\n * Error message constants for consistent error reporting\n */\nexport const ERROR_MESSAGES = {\n    INVALID_CONTAINER: 'Container must be a valid DOM element',\n    INVALID_HTML: 'HTML content must be a string',\n    INVALID_CSS: 'Styles must be a string',\n    INVALID_DATA: 'Data must be an object',\n    INVALID_TARGET_WIDTH: 'Target width must be a positive number',\n    ELEMENT_DESTROYED: 'Card has been destroyed and cannot perform operations'\n};","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","import { ERROR_MESSAGES } from './constants.js';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Generates a unique ID for card identification\n * @returns {string} Unique alphanumeric ID\n */\nexport function generateUniqueId() {\n    return `shadow-card-${uuidv4()}`;\n}\n\n/**\n * Input validation utility for ensuring type safety and valid values\n */\nexport const Validator = {\n    /**\n     * Validates that a container is a valid HTML element\n     * @param {*} container - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateContainer(container) {\n        if (!(container instanceof HTMLElement)) {\n            throw new Error(ERROR_MESSAGES.INVALID_CONTAINER);\n        }\n    },\n\n    /**\n     * Validates that HTML content is a string\n     * @param {*} html - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateHtml(html) {\n        if (typeof html !== 'string') {\n            throw new Error(ERROR_MESSAGES.INVALID_HTML);\n        }\n    },\n\n    /**\n     * Validates that CSS content is a string\n     * @param {*} css - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateCss(css) {\n        if (typeof css !== 'string') {\n            throw new Error(ERROR_MESSAGES.INVALID_CSS);\n        }\n    },\n\n    /**\n     * Validates that data is a valid object\n     * @param {*} data - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateData(data) {\n        if (data !== null && typeof data !== 'object') {\n            throw new Error(ERROR_MESSAGES.INVALID_DATA);\n        }\n    },\n\n    /**\n     * Validates that target width is a positive number\n     * @param {*} width - Value to validate\n     * @throws {Error} Throws error if validation fails\n     */\n    validateTargetWidth(width) {\n        if (typeof width !== 'number' || width <= 0 || isNaN(width)) {\n            throw new Error(ERROR_MESSAGES.INVALID_TARGET_WIDTH);\n        }\n    },\n\n    /**\n     * Validates that a card instance hasn't been destroyed\n     * @param {Object} instance - Card instance to check\n     * @throws {Error} Throws error if instance is destroyed\n     */\n    validateNotDestroyed(instance) {\n        if (instance.isDestroyed) {\n            throw new Error(ERROR_MESSAGES.ELEMENT_DESTROYED);\n        }\n    }\n};","import { generateUniqueId, Validator } from './utils.js';\nimport { DEFAULT_OPTIONS, EVENT_TYPES } from './constants.js';\n\n/**\n * ShadowCard class - Creates isolated card instances using Shadow DOM\n */\nexport class ShadowCard {\n    constructor(options = {}) {\n        try {\n            // Merge defaults and ensure object shape\n            this.options = { ...(DEFAULT_OPTIONS || {}), ...(options || {}) };\n            // ensure container fallback\n            this.options.container = this.options.container || document.body;\n            // basic init\n            this.id = generateUniqueId ? generateUniqueId() : `shadow-card-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;\n            this.isDestroyed = false;\n            this.data = { ...this.options.data };\n            this.eventListeners = new Map();\n            this.resizeTimer = null;\n\n            // Validate using Validator if available (defensive)\n            try {\n                if (Validator && typeof Validator.validateContainer === 'function') {\n                    Validator.validateContainer(this.options.container);\n                }\n                if (Validator && typeof Validator.validateHtml === 'function') {\n                    Validator.validateHtml(this.options.html);\n                }\n                if (Validator && typeof Validator.validateCss === 'function') {\n                    Validator.validateCss(this.options.css);\n                }\n                if (Validator && typeof Validator.validateData === 'function') {\n                    Validator.validateData(this.options.data);\n                }\n                if (Validator && typeof Validator.validateTargetWidth === 'function') {\n                    Validator.validateTargetWidth(this.options.targetWidth);\n                }\n            } catch (validationErr) {\n                // Emit and rethrow - keep stack for developer\n                this.dispatchError(validationErr?.message || String(validationErr));\n                throw validationErr;\n            }\n\n            // Build DOM\n            this.element = this.createHostElement();\n            this.shadow = this.element.shadowRoot;\n            this.innerContainer = this.shadow && this.shadow.getElementById('inner-container');\n\n            // Initialize content and styles (use safe calls)\n            this.setHTML(this.options.html || '');\n            if (this.options.css) this.setStyle(this.options.css);\n            if (this.options.data) this.setContent(this.options.data);\n\n            // Append to container\n            this.options.container.appendChild(this.element);\n\n            // Defer resize to next tick\n            this.resizeTimer = setTimeout(() => {\n                // ignore errors here; resize handles its own errors and dispatches them\n                this.resize().catch(() => {});\n            }, 0);\n\n        } catch (error) {\n            // if constructor fails, attempt to dispatch error (guarded)\n            try { this.dispatchError(error?.message || String(error)); } catch (_) {}\n            throw error;\n        }\n    }\n\n    /**\n     * Wait for all images in the card to load, optional timeout in ms.\n     * @param {Object} [opts] - { timeoutMs: number }\n     * @returns {Promise}\n     */\n    waitForImages(opts = {}) {\n        const timeoutMs = (opts && Number(opts.timeoutMs)) || 0;\n        return new Promise((resolve) => {\n            try {\n                const imgs = this.shadow ? Array.from(this.shadow.querySelectorAll('img')) : [];\n                if (!imgs.length) {\n                    resolve();\n                    return;\n                }\n                let processed = 0;\n                const total = imgs.length;\n                const done = () => {\n                    processed++;\n                    if (processed >= total) resolve();\n                };\n\n                imgs.forEach(img => {\n                    // already processed\n                    if (img.complete) {\n                        done();\n                        return;\n                    }\n                    // add listeners once\n                    const onDone = () => {\n                        img.removeEventListener('load', onDone);\n                        img.removeEventListener('error', onDone);\n                        done();\n                    };\n                    img.addEventListener('load', onDone, { once: true });\n                    img.addEventListener('error', onDone, { once: true });\n                });\n\n                if (timeoutMs > 0) {\n                    setTimeout(() => {\n                        // timeout: resolve even if not all images loaded\n                        resolve();\n                    }, timeoutMs);\n                }\n            } catch (err) {\n                // on unexpected errors, resolve to avoid blocking\n                resolve();\n            }\n        });\n    }\n\n    createHostElement() {\n        const element = document.createElement('shadow-card');\n        element.id = this.id;\n        element.dataset.id = this.id;\n\n        // Apply style variables based on options\n        this.applyStyleVariables(element);\n\n        const shadow = element.attachShadow({ mode: 'open' });\n\n        // NOTE: use /* */ style comments, avoid '//' inside CSS\n        shadow.innerHTML = `\n        <style>\n        :host {\n            all: initial;\n            display: block;\n            border: var(--shadow-card-border, 2px solid var(--shadow-card-border-color));\n            border-radius: var(--shadow-card-border-radius, 6px);\n            cursor: pointer;\n            overflow: hidden;\n            box-sizing: border-box;\n            transition: border 0.3s ease;\n            user-select: none;\n            position: relative;\n            margin: ${this.options?.styles?.margin || '8px auto'};\n            width: ${this.options?.targetWidth ? `${Number(this.options.targetWidth)}px` : 'auto'};\n        }\n        \n        :host(:hover) {\n            border-color: var(--shadow-card-hover-border-color, #3b82f6);\n        }\n        \n        #inner-container {\n            /* width: 100%; */\n            width:640px;\n            transform-origin: top left;\n            transform: scale(1);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n\n        #loading-overlay {\n            position: absolute;\n            inset: 0;\n            background: var(--shadow-card-loading-bg, #ffffff);\n            color: var(--shadow-card-loading-color, #4b5563);\n            font-size: var(--shadow-card-loading-font-size, 0.8rem);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            gap: var(--shadow-card-loading-gap, 8px);\n            z-index: 10;\n            opacity: 1;\n            transition: opacity 0.3s ease;\n        }\n        \n        .loading-spinner {\n            width: var(--shadow-card-loading-icon-size, 20px);\n            height: var(--shadow-card-loading-icon-size, 20px);\n            border: 2px solid var(--shadow-card-loading-spinner-border, rgba(0, 0, 0, 0.1));\n            border-top-color: var(--shadow-card-loading-spinner-color, #3b82f6);\n            border-radius: 50%;\n            animation: spin var(--shadow-card-loading-spinner-speed, 1s) linear infinite;\n        }\n        \n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n        \n        #loading-overlay.hidden {\n            opacity: 0;\n            pointer-events: none;\n        }\n        </style>\n        <div id=\"loading-overlay\">\n            <div class=\"loading-spinner\" aria-hidden=\"true\"></div>\n            <span class=\"loading-text\">${this.options?.styles?.loadingText || 'Loading...'}</span>\n        </div>\n        <div id=\"inner-container\" role=\"region\" aria-label=\"shadow-card-content\"></div>\n    `;\n\n        // bind handlers so they can be removed later\n        this.boundInputHandler = (e) => this.handleInput(e);\n        this.boundClickHandler = (e) => this.handleClick(e);\n        this.boundPasteHandler = (e) => this.handlePaste(e);\n\n        // events attached to shadow root so they are scoped\n        shadow.addEventListener('input', this.boundInputHandler);\n        shadow.addEventListener('click', this.boundClickHandler);\n        shadow.addEventListener('paste', this.boundPasteHandler);\n\n        return element;\n    }\n\n    /**\n     * Improved paste handler:\n     * - preventDefault early\n     * - sanitize HTML\n     * - try document.execCommand('insertHTML') for undo support\n     * - fallback to Range.insertNode if needed\n     */\n    handlePaste(e) {\n        if (this.isDestroyed) return;\n        if (!e) return;\n\n        // de-dupe\n        if (e.__shadowCardHandled) return;\n        try {\n            Object.defineProperty(e, '__shadowCardHandled', { value: true, configurable: true });\n        } catch (err) {\n            e.__shadowCardHandled = true;\n        }\n\n        // try to prevent native paste behavior\n        try {\n            if (typeof e.preventDefault === 'function') e.preventDefault();\n            if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();\n            if (typeof e.stopPropagation === 'function') e.stopPropagation();\n        } catch (_) {}\n\n        let editableEl = e.target;\n        while (editableEl && editableEl.nodeType === Node.ELEMENT_NODE && !editableEl.isContentEditable) {\n            editableEl = editableEl.parentElement;\n        }\n        if (!editableEl || !editableEl.isContentEditable) {\n            return;\n        }\n\n        // Get clipboard data (defensive)\n        const clipboard = (e.clipboardData || window.clipboardData);\n        if (!clipboard) {\n            // nothing we can do\n            return;\n        }\n\n        const rawHtml = clipboard.getData('text/html') || '';\n        const plainText = clipboard.getData('text') || '';\n\n        // choose html if present, otherwise plain text\n        const htmlToSanitize = rawHtml.trim() !== '' ? rawHtml : (plainText ? this.escapeHtml(plainText).replace(/\\n/g, '<br/>') : '');\n\n        if (!htmlToSanitize) return;\n\n        // sanitize\n        const sanitized = (typeof this.sanitizeHtmlContent === 'function') ? this.sanitizeHtmlContent(htmlToSanitize) : htmlToSanitize;\n\n        // Obtain selection in a shadow-aware way\n        let selection = null;\n        try {\n            const rootNode = editableEl.getRootNode && editableEl.getRootNode();\n            if (rootNode && typeof rootNode.getSelection === 'function') {\n                selection = rootNode.getSelection();\n            }\n            if (!selection) selection = window.getSelection();\n        } catch (_) {\n            selection = window.getSelection();\n        }\n\n        // ensure focus so execCommand works with correct target\n        try { editableEl.focus(); } catch (_) {}\n\n        // Attempt to use execCommand('insertHTML') for undo integration (best effort)\n        if (typeof document.execCommand === 'function') {\n            try {\n                // set selection range if possible\n                if (selection && selection.rangeCount > 0) {\n                    // If range not inside editableEl, collapse to end of editableEl\n                    let range = selection.getRangeAt(0);\n                    if (!editableEl.contains(range.startContainer)) {\n                        range = document.createRange();\n                        range.selectNodeContents(editableEl);\n                        range.collapse(false);\n                        try { selection.removeAllRanges(); selection.addRange(range); } catch (_) {}\n                    }\n                } else if (selection) {\n                    try {\n                        const range = document.createRange();\n                        range.selectNodeContents(editableEl);\n                        range.collapse(false);\n                        selection.removeAllRanges();\n                        selection.addRange(range);\n                    } catch (_) {}\n                }\n\n                // execCommand will insert the HTML at current selection and create undo snapshot\n                const ok = document.execCommand('insertHTML', false, sanitized);\n                if (ok) {\n                    return;\n                }\n                // fallthrough to manual insertion if execCommand returned falsy\n            } catch (execErr) {\n                // ignore and fallback to manual insertion\n            }\n        }\n\n        // Fallback: manual insertion using Range (try to preserve selection)\n        try {\n            let range = (selection && selection.rangeCount > 0) ? selection.getRangeAt(0).cloneRange() : null;\n            if (!range || !editableEl.contains(range.startContainer)) {\n                range = document.createRange();\n                range.selectNodeContents(editableEl);\n                range.collapse(false);\n            } else {\n                // remove currently selected contents so paste replaces them\n                range.deleteContents();\n            }\n\n            // Create fragment from sanitized HTML\n            const temp = document.createElement('div');\n            temp.innerHTML = sanitized;\n            const frag = document.createDocumentFragment();\n            let lastNode = null;\n            while (temp.firstChild) {\n                lastNode = frag.appendChild(temp.firstChild);\n            }\n\n            range.insertNode(frag);\n\n            // restore selection after inserted content\n            if (lastNode) {\n                try {\n                    const newRange = document.createRange();\n                    newRange.setStartAfter(lastNode);\n                    newRange.collapse(true);\n                    if (selection) {\n                        selection.removeAllRanges();\n                        selection.addRange(newRange);\n                    }\n                } catch (_) { /* ignore */ }\n            }\n        } catch (err) {\n            // Final fallback: append plain text node\n            try {\n                const fallbackText = plainText || '';\n                const tn = document.createTextNode(fallbackText);\n                editableEl.appendChild(tn);\n            } catch (innerErr) {\n                console.error('Paste fallback failed:', innerErr);\n            }\n        }\n    }\n\n    /**\n     * Escape plain text -> safe html (used when only plain text available)\n     */\n    escapeHtml(str = '') {\n        return String(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    }\n\n    /**\n     * Sanitizes HTML to allow only basic formatting tags & allowed attributes.\n     * More defensive: removes style/class/on* handlers and strips unknown tags.\n     */\n    sanitizeHtmlContent(html = '') {\n        if (!html || typeof html !== 'string') return '';\n\n        const ALLOWED_TAGS = new Set(['b', 'i', 'strong', 'em', 'u', 's', 'sub', 'sup', 'span', 'br', 'p', 'div']);\n        const ALLOWED_ATTRS = new Set(['data-field', 'data-img']); // permit only these data attrs\n\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(`<div>${html}</div>`, 'text/html');\n        const container = doc.body.firstChild;\n        if (!container) return '';\n\n        const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);\n        const toRemove = [];\n\n        // collect nodes to examine (can't mutate while walking directly)\n        const nodes = [];\n        let node = walker.nextNode();\n        while (node) {\n            nodes.push(node);\n            node = walker.nextNode();\n        }\n\n        nodes.forEach(n => {\n            if (n.nodeType === Node.COMMENT_NODE) {\n                toRemove.push(n);\n                return;\n            }\n            if (n.nodeType === Node.ELEMENT_NODE) {\n                const tag = n.tagName.toLowerCase();\n                if (!ALLOWED_TAGS.has(tag)) {\n                    // replace node by its children (preserve text)\n                    const parent = n.parentNode;\n                    while (n.firstChild) parent.insertBefore(n.firstChild, n);\n                    toRemove.push(n);\n                    return;\n                }\n                // sanitize attributes: remove any attr not explicitly allowed\n                for (let i = n.attributes.length - 1; i >= 0; i--) {\n                    const attr = n.attributes[i];\n                    const name = attr.name.toLowerCase();\n                    // remove event handlers, style, class, id, etc\n                    if (!ALLOWED_ATTRS.has(name)) {\n                        n.removeAttribute(attr.name);\n                    } else {\n                        // allowed data- attributes: ensure value simple\n                        const v = String(attr.value || '');\n                        // disallow javascript: urls etc in case someone put them on data attr (unlikely but defensive)\n                        if (/^\\s*javascript:/i.test(v)) {\n                            n.removeAttribute(attr.name);\n                        }\n                    }\n                }\n            }\n        });\n\n        toRemove.forEach(r => r.parentNode && r.parentNode.removeChild(r));\n        // return innerHTML of sanitized container\n        return container.innerHTML;\n    }\n\n    applyStyleVariables(element) {\n        if (!element || !(element instanceof HTMLElement)) return;\n        try {\n            const styleMappings = this.getStyleMappings();\n            if (this.options?.styles && typeof this.options.styles === 'object') {\n                Object.entries(styleMappings).forEach(([optionKey, cssVar]) => {\n                    if (this.options.styles[optionKey] !== undefined) {\n                        try {\n                            element.style.setProperty(cssVar, this.options.styles[optionKey]);\n                        } catch (_) {}\n                    }\n                });\n            }\n        } catch (err) {\n            console.error('applyStyleVariables error', err);\n        }\n    }\n\n    getStyleMappings() {\n        return {\n            border: '--shadow-card-border',\n            borderColor: '--shadow-card-border-color',\n            borderRadius: '--shadow-card-border-radius',\n            hoverBorderColor: '--shadow-card-hover-border-color',\n            loadingBg: '--shadow-card-loading-bg',\n            loadingColor: '--shadow-card-loading-color',\n            loadingFontSize: '--shadow-card-loading-font-size',\n            loadingGap: '--shadow-card-loading-gap',\n            loadingIconSize: '--shadow-card-loading-icon-size',\n            loadingSpinnerBorder: '--shadow-card-loading-spinner-border',\n            loadingSpinnerColor: '--shadow-card-loading-spinner-color',\n            loadingSpinnerSpeed: '--shadow-card-loading-spinner-speed',\n            loadingText: '--shadow-card-loading-text'\n        };\n    }\n\n    setCssVariables(variables) {\n        try {\n            if (this.isDestroyed) return this;\n            if (!variables || typeof variables !== 'object') throw new Error('Style variables must be an object');\n            const styleMappings = this.getStyleMappings();\n            Object.entries(variables).forEach(([optionKey, value]) => {\n                const cssVar = styleMappings[optionKey];\n                if (cssVar && value !== undefined) {\n                    try { this.element.style.setProperty(cssVar, value); } catch (_) {}\n                }\n            });\n            if (variables.loadingText && this.shadow) {\n                const loadingTextEl = this.shadow.querySelector('.loading-text');\n                if (loadingTextEl) loadingTextEl.textContent = variables.loadingText;\n            }\n            return this;\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n            return this;\n        }\n    }\n\n    handleInput(e) {\n        if (this.isDestroyed) return;\n        try {\n            const target = e.target;\n            if (!target) return;\n            if (target.isContentEditable && target.hasAttribute('data-field')) {\n                const field = target.getAttribute('data-field');\n                const value = target.innerText;\n                this.data = this.data || {};\n                this.data[field] = value;\n                this.dispatchEvent(EVENT_TYPES.CONTENT_CHANGE, { field, value });\n            }\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n        }\n    }\n\n    handleClick(e) {\n        if (this.isDestroyed) return;\n        try {\n            const target = e.target;\n            if (!target) return;\n            if (target.tagName === 'IMG' && target.hasAttribute('data-img')) {\n                this.dispatchEvent(EVENT_TYPES.IMG_CLICK, {\n                    imgKey: target.getAttribute('data-img'),\n                    element: target\n                });\n            }\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n        }\n    }\n\n    dispatchEvent(type, detail = {}) {\n        if (this.isDestroyed || !this.element) return;\n        try {\n            const evt = new CustomEvent(type, {\n                detail: { ...detail, cardId: this.id },\n                bubbles: true,\n                cancelable: true\n            });\n            this.element.dispatchEvent(evt);\n            // also call any listeners added via on()\n            const handlers = this.eventListeners.get(type);\n            if (handlers && handlers.size) {\n                handlers.forEach(h => {\n                    try { h(evt); } catch (_) {}\n                });\n            }\n        } catch (err) {\n            // swallow errors from event dispatch but log\n            console.error('dispatchEvent error', err);\n        }\n    }\n\n    dispatchError(message) {\n        try {\n            this.dispatchEvent(EVENT_TYPES.ERROR, { message });\n        } catch (_) {}\n    }\n\n    async setHTML(html = '') {\n        try {\n            if (this.isDestroyed) return this;\n            if (Validator && typeof Validator.validateHtml === 'function') Validator.validateHtml(html);\n            if (this.innerContainer) {\n                this.innerContainer.innerHTML = html || '';\n                // force reflow\n                void this.innerContainer.offsetHeight;\n                await this.resize();\n            }\n            return this;\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n            return this;\n        }\n    }\n\n    setStyle(css = '', reset = false) {\n        try {\n            if (this.isDestroyed) return this;\n            if (Validator && typeof Validator.validateCss === 'function') Validator.validateCss(css);\n            if (!this.shadow) return this;\n            let styleEl = this.shadow.querySelector('#custom-style');\n            if (!styleEl) {\n                styleEl = document.createElement('style');\n                styleEl.id = 'custom-style';\n                // insert before inner container\n                const ref = this.shadow.getElementById('inner-container');\n                this.shadow.insertBefore(styleEl, ref);\n            }\n            styleEl.textContent = reset ? (css || '') : `${styleEl.textContent || ''}\\n${css || ''}`;\n            return this;\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n            return this;\n        }\n    }\n\n    setContent(data = {}) {\n        try {\n            if (this.isDestroyed) return this;\n            if (Validator && typeof Validator.validateData === 'function') Validator.validateData(data);\n            this.data = { ...(this.data || {}), ...(data || {}) };\n            if (!this.shadow) return this;\n            Object.entries(data || {}).forEach(([field, value]) => {\n                const el = this.shadow.querySelector(`[data-field=\"${field}\"]`);\n                if (el && el.isContentEditable) {\n                    el.innerText = value == null ? '' : String(value);\n                }\n            });\n            return this;\n        } catch (err) {\n            this.dispatchError(err?.message || String(err));\n            return this;\n        }\n    }\n\n    async resize(targetWidth) {\n        try {\n            if (this.isDestroyed) return this;\n            if (Validator && typeof Validator.validateNotDestroyed === 'function') Validator.validateNotDestroyed(this);\n\n            const loadingOverlay = this.shadow && this.shadow.querySelector('#loading-overlay');\n            if (loadingOverlay) loadingOverlay.classList.remove('hidden');\n\n            if (targetWidth !== undefined && Validator && typeof Validator.validateTargetWidth === 'function') {\n                Validator.validateTargetWidth(targetWidth);\n                this.options.targetWidth = Number(targetWidth);\n            }\n            const targetW = Number(this.options.targetWidth) || 160;\n\n            if (!this.element || !this.innerContainer) {\n                if (loadingOverlay) loadingOverlay.classList.add('hidden');\n                return this;\n            }\n\n            // set host width to target width for measurement\n            this.element.style.width = `${targetW}px`;\n            this.element.style.height = 'auto';\n\n            // wait for images with a sensible timeout\n            await this.waitForImages({ timeoutMs: 5000 });\n\n            // measure original size (temporarily reset transform)\n            const prevTransform = this.innerContainer.style.transform || '';\n            this.innerContainer.style.transform = 'scale(1)';\n            this.innerContainer.style.transformOrigin = 'top left';\n            // trigger reflow & measure\n            void this.innerContainer.offsetHeight;\n            const rect = this.innerContainer.getBoundingClientRect();\n            const originalContentWidth = Math.max(1, rect.width || 1);\n            const originalContentHeight = Math.max(1, rect.height || 1);\n\n            const scale = Math.min(1, targetW / originalContentWidth);\n\n            // set width for inner container (reverse-engineered) before scaling to preserve layout\n            const innerWidth = Math.round(targetW / Math.max(scale, 0.0001));\n            this.innerContainer.style.width = `${innerWidth}px`;\n            this.innerContainer.style.overflow = 'hidden';\n\n            // apply scale\n            this.innerContainer.style.transform = `scale(${scale})`;\n            this.innerContainer.style.transformOrigin = 'top left';\n\n            const scaledHeight = Math.max(1, Math.round(originalContentHeight * scale));\n            this.element.style.height = `${scaledHeight}px`;\n\n            // hide loading after paint\n            requestAnimationFrame(() => {\n                loadingOverlay?.classList.add('hidden');\n            });\n\n            return this;\n        } catch (err) {\n            try { this.shadow?.querySelector('#loading-overlay')?.classList.add('hidden'); } catch (_) {}\n            this.dispatchError(err?.message || String(err));\n            return this;\n        }\n    }\n\n    on(type, handler) {\n        if (this.isDestroyed) return this;\n        if (typeof handler !== 'function') {\n            this.dispatchError('Event handler must be a function');\n            return this;\n        }\n        if (!this.eventListeners.has(type)) this.eventListeners.set(type, new Set());\n        const set = this.eventListeners.get(type);\n        set.add(handler);\n        // add DOM listener so event can be captured normally\n        try { this.element.addEventListener(type, handler); } catch (_) {}\n        return this;\n    }\n\n    off(type, handler) {\n        if (this.isDestroyed) return this;\n        const handlers = this.eventListeners.get(type);\n        if (!handlers) return this;\n        if (handler) {\n            handlers.delete(handler);\n            try { this.element.removeEventListener(type, handler); } catch (_) {}\n        } else {\n            handlers.forEach(h => {\n                try { this.element.removeEventListener(type, h); } catch (_) {}\n            });\n            handlers.clear();\n        }\n        // if empty, remove the key\n        if (handlers.size === 0) this.eventListeners.delete(type);\n        return this;\n    }\n\n    destroy() {\n        if (this.isDestroyed) return;\n        clearTimeout(this.resizeTimer);\n\n        // remove custom event listeners\n        this.eventListeners.forEach((handlers, type) => {\n            handlers.forEach(handler => {\n                try { this.element.removeEventListener(type, handler); } catch (_) {}\n            });\n        });\n        this.eventListeners.clear();\n\n        // remove shadow-scoped listeners\n        try {\n            this.shadow?.removeEventListener('input', this.boundInputHandler);\n            this.shadow?.removeEventListener('click', this.boundClickHandler);\n            this.shadow?.removeEventListener('paste', this.boundPasteHandler);\n        } catch (_) {}\n\n        // remove DOM element\n        try { this.element?.parentNode?.removeChild(this.element); } catch (_) {}\n\n        // nullify references\n        this.isDestroyed = true;\n        this.element = null;\n        this.shadow = null;\n        this.innerContainer = null;\n        this.data = null;\n        this.options = null;\n        this.boundInputHandler = null;\n        this.boundClickHandler = null;\n        this.boundPasteHandler = null;\n    }\n\n    static batchCreate(cards) {\n        if (!Array.isArray(cards)) throw new Error('batchCreate requires an array of card configurations');\n        return cards.map(options => new ShadowCard(options));\n    }\n}\n\nexport default ShadowCard;\n"],"names":["DEFAULT_OPTIONS","targetWidth","container","document","body","html","css","data","EVENT_TYPES","ERROR_MESSAGES","byteToHex","i","push","toString","slice","getRandomValues","rnds8","Uint8Array","native","randomUUID","crypto","bind","_v4","options","buf","offset","rnds","random","rng","Error","length","arr","toLowerCase","unsafeStringify","generateUniqueId","Validator","validateContainer","HTMLElement","validateHtml","validateCss","validateData","validateTargetWidth","width","isNaN","validateNotDestroyed","instance","isDestroyed","ShadowCard","constructor","this","id","Date","now","Math","eventListeners","Map","resizeTimer","validationErr","dispatchError","message","String","element","createHostElement","shadow","shadowRoot","innerContainer","getElementById","setHTML","setStyle","setContent","appendChild","setTimeout","resize","catch","error","_","waitForImages","opts","timeoutMs","Number","Promise","resolve","imgs","Array","from","querySelectorAll","processed","total","done","forEach","img","complete","onDone","removeEventListener","addEventListener","once","err","createElement","dataset","applyStyleVariables","attachShadow","mode","innerHTML","styles","margin","loadingText","boundInputHandler","e","handleInput","boundClickHandler","handleClick","boundPasteHandler","handlePaste","__shadowCardHandled","Object","defineProperty","value","configurable","preventDefault","stopImmediatePropagation","stopPropagation","editableEl","target","nodeType","Node","ELEMENT_NODE","isContentEditable","parentElement","clipboard","clipboardData","window","rawHtml","getData","plainText","htmlToSanitize","trim","escapeHtml","replace","sanitized","sanitizeHtmlContent","selection","rootNode","getRootNode","getSelection","focus","execCommand","rangeCount","range","getRangeAt","contains","startContainer","createRange","selectNodeContents","collapse","removeAllRanges","addRange","execErr","cloneRange","deleteContents","temp","frag","createDocumentFragment","lastNode","firstChild","insertNode","newRange","setStartAfter","fallbackText","tn","createTextNode","innerErr","console","str","ALLOWED_TAGS","Set","ALLOWED_ATTRS","DOMParser","parseFromString","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","SHOW_COMMENT","toRemove","nodes","node","nextNode","n","COMMENT_NODE","tag","tagName","has","parent","parentNode","insertBefore","attributes","attr","name","v","test","removeAttribute","r","removeChild","styleMappings","getStyleMappings","entries","optionKey","cssVar","undefined","style","setProperty","border","borderColor","borderRadius","hoverBorderColor","loadingBg","loadingColor","loadingFontSize","loadingGap","loadingIconSize","loadingSpinnerBorder","loadingSpinnerColor","loadingSpinnerSpeed","setCssVariables","variables","loadingTextEl","querySelector","textContent","hasAttribute","field","getAttribute","innerText","dispatchEvent","imgKey","type","detail","evt","CustomEvent","cardId","bubbles","cancelable","handlers","get","size","h","offsetHeight","reset","styleEl","ref","el","loadingOverlay","classList","remove","targetW","add","height","transform","transformOrigin","rect","getBoundingClientRect","originalContentWidth","max","originalContentHeight","scale","min","innerWidth","round","overflow","scaledHeight","requestAnimationFrame","on","handler","set","off","delete","clear","destroy","clearTimeout","batchCreate","cards","isArray","map"],"mappings":"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","x_google_ignoreList":[1,2,3,4]}